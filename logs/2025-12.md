# 2025-12 作業ログ

## 2025-12-13 speak-itプロジェクト立ち上げ

### 概要
テキスト読み上げWebアプリ「speak-it」を新規作成。

### 作業内容

#### 1. プロジェクト初期化
- Vite + Vanilla JS でセットアップ
- 基本UI実装（テキストエリア、音声選択、速度/音量調整、再生ボタン）

#### 2. Web Speech API でMVP
- ブラウザ内蔵の音声合成で動作確認
- 問題なく動作するが、音声品質に限界あり

#### 3. Google Cloud TTS 統合
- APIキー取得、REST API経由で音声生成
- **重大な問題発生**: MP3形式で約70文字付近で音声が途切れる

#### 4. 問題解決の試行錯誤
| 試したこと | 結果 |
|-----------|------|
| チャンク分割（200文字→100文字） | 効果なし |
| OGG_OPUS形式 | 効果なし |
| Blob URL | 効果なし |
| DOM audio要素 | 効果なし |
| canplaythrough待ち | 効果なし |

#### 5. 解決策: LINEAR16 + AudioContext
- **MP3ではなくLINEAR16（生PCM）形式**を使用
- AudioContext APIで直接再生
- base64 → Int16Array → Float32Array → AudioBuffer の変換処理

#### 6. チャンク間のブツ切れ問題
- チャンク分割をやめ、**1回のAPIコールで全文送信**
- 300文字程度なら5000バイト制限に収まる

#### 7. 開始時クリックノイズ
- GainNodeで**20msフェードイン**を適用
- `linearRampToValueAtTime`で滑らかに音量を上げる

### 技術的教訓
1. **Google Cloud TTS + ブラウザでMP3は要注意**: デコーダーの問題で途中から再生が途切れることがある
2. **LINEAR16が安定**: 生PCMデータは変換が必要だが確実に動作
3. **AudioContext APIを使う**: Audio要素より低レベルで制御でき、安定している
4. **クリックノイズ対策にはフェードイン**: 急激な音量変化を避ける

#### 8. 長文対応（バッファ連結方式）
- **問題**: Google Cloud TTS API は5000バイト/リクエストの制限
- **以前の失敗**: チャンクを順次再生 → チャンク間で「ブツッ」ノイズ
- **解決策**: バッファ連結方式
  1. 長文を4500バイト以下のチャンクに分割（段落→文末→読点の優先順位）
  2. 全チャンク並列でAPI呼び出し（高速化）
  3. Float32Arrayとして連結
  4. 単一AudioBufferとして再生
- **結果**: チャンク境界でノイズなし、シームレス再生成功
- **テスト**: 7160バイト → 2チャンク分割 → 458秒の音声をノイズなし再生

### 技術的教訓
1. **Google Cloud TTS + ブラウザでMP3は要注意**: デコーダーの問題で途中から再生が途切れることがある
2. **LINEAR16が安定**: 生PCMデータは変換が必要だが確実に動作
3. **AudioContext APIを使う**: Audio要素より低レベルで制御でき、安定している
4. **クリックノイズ対策にはフェードイン**: 急激な音量変化を避ける
5. **長文はバッファ連結**: 順次再生ではなく、連結してから再生でノイズ回避

#### 9. バグ修正・機能追加
- **冒頭ノイズ再発** → GainNodeフェードインからデータレベルフェードイン（50ms）に変更
- **一時停止機能** → `AudioContext.suspend()/resume()`で実装
- **リアルタイム音量調整** → GainNode経由で再生中も変更可能に
- **速度変更** → 再生中の変更は音程が変わるため、次の再生から反映する仕様に

### 残課題
- 音声ダウンロード機能
- APIキーのセキュリティ対策

## 2025-12-14 Renderデプロイ

### 概要
speak-itをRenderにデプロイ。フロントエンド（Static Site）+ バックエンド（Web Service）の構成。

### 作業内容

#### 1. render.yaml作成・修正
- Blueprint方式でのデプロイ設定
- **問題1**: `fromService.property: url` が無効 → 手動環境変数設定方式に変更
- **問題2**: Static Siteに `plan: free` は指定不可 → 削除

#### 2. バックエンドAPIプロキシ
- `server/index.js`: Express + CORS設定
- Google TTS APIキーをサーバー側で管理（セキュリティ対策）
- エンドポイント: `/api/voices`, `/api/synthesize`, `/health`

#### 3. 環境変数問題
- **問題**: Viteの `import.meta.env.VITE_API_URL` がビルド時に反映されない
- **原因**: Render Static Siteでのビルド時環境変数の扱い
- **解決**: ホスト名による自動判定フォールバックを実装
  ```javascript
  const API_BASE_URL = import.meta.env.VITE_API_URL ||
    (window.location.hostname === 'localhost' ? 'http://localhost:3001' : 'https://speak-it-api.onrender.com');
  ```

#### 4. デプロイ完了
- フロントエンド: https://speak-it.onrender.com
- バックエンド: https://speak-it-api.onrender.com
- 動作確認OK

### 技術的教訓
1. **Render Blueprint**: `fromService.property` で `url` は使えない（`host`, `port` 等のみ）
2. **Vite環境変数**: Static Siteではビルド時に反映されない場合あり、フォールバック実装推奨
3. **無料プラン注意**: 15分無操作でスピンダウン、再起動に50秒程度かかる

## 2025-12-14 マークダウン記号自動除去機能

### 概要
AI出力（Gemini等）のマークダウン形式テキストをそのまま貼り付けても、`#`や`*`が読み上げられないよう自動除去機能を実装。

### 作業内容

#### 1. stripMarkdown関数の実装
`src/main.js`に`stripMarkdown(text)`メソッドを追加。以下の記号を除去：
- コードブロック ` ``` `
- インラインコード `` ` ``
- 画像 `![alt](url)` → 除去
- リンク `[text](url)` → textのみ
- 太字 `**text**` / `__text__`
- 斜体 `*text*` / `_text_`
- ヘッダー `# ` 〜 `###### `
- リストマーカー `- ` `* ` `+ `
- 引用 `> `
- 水平線 `---`
- 取り消し線 `~~text~~`

#### 2. バグ修正1: ヘッダー記号のスペースなし対応
- **問題**: `#タイトル`（スペースなし）が除去されない
- **原因**: `/^#{1,6}\s+/` が「スペース1つ以上必須」を要求
- **修正**: `/^[\s]*#{1,6}\s*/` に変更（行頭インデント許容、スペース任意）

#### 3. バグ修正2: 章番号が消える問題
- **問題**: `###1. Claude Code` → ヘッダー除去後に番号付きリスト除去で `Claude Code` になる
- **原因**: `/^[\s]*\d+\.\s+/` が章番号もリストマーカーとして除去
- **修正**: 番号付きリスト除去を廃止（章番号を保持）

#### 4. キャッシュ問題
- デプロイ後、ユーザーブラウザのキャッシュで古いJSが読み込まれていた
- ハードリロード（Ctrl+Shift+R）で解決
- **教訓**: デプロイ後は「キャッシュクリアして試して」と先に伝えるべき

### 技術的知見
1. **正規表現の順序**: コードブロック→インラインコード→その他の順で処理（中の記号が誤爆しないように）
2. **貪欲マッチに注意**: `\s+`と`\s*`の違いが挙動を大きく変える
3. **ブラウザキャッシュ**: Playwrightテストと実ユーザーブラウザで結果が異なる場合はキャッシュを疑う

### 余談: Google Antigravityとの比較
- ブラウザ自動化において、Claude Code + Playwright MCPとGoogle Antigravityは同じ土俵
- どちらも新しいブラウザインスタンス/プロファイルを操作し、ユーザーの既存ブラウザには触れない
- セキュリティ上、これは当然の設計

## 2025-12-14 テキスト処理改善・音声ダウンロード機能

### 概要
YouTube動画解説テキスト読み上げ向けの改善と、音声ダウンロード機能を追加。

### 作業内容

#### 1. YouTubeタイムスタンプ除去
- **要望**: `[00:13:40]` 形式が「れいじじゅうさんぷんよんじゅうびょう」と読まれる
- **対応**: 正規表現 `/\[\d{1,2}:\d{2}(:\d{2})?\]/g` で除去
- `[HH:MM:SS]` と `[MM:SS]` 両方に対応

#### 2. 区切り記号を読点に変換
- **要望**: `:` `;` で1拍開けたい（現状は繋がって読まれる）
- **対応**: `/[:;：；]/g` を `、` に変換（全角も対応）
- Google Cloud TTSが読点で自然に間を取るように

#### 3. 音声ダウンロード機能
- **WAV形式**: LINEAR16をそのままWAVヘッダー付きで保存
- **長文対応**: チャンク分割→並列生成→連結→WAV出力
- **UI**: 緑色の「保存」ボタンを追加
- **制限**: Google Cloud TTSのみ対応（ブラウザ音声は非対応）

#### 4. ボタンテキスト修正
- **問題**: 「⬇ ダウンロード」が折り返して見苦しい
- **原因**: 4ボタン横並びで幅不足
- **対応**: 「⬇ 保存」に短縮
- **反省**: UI変更後はPlaywrightで自分の目で確認すべきだった

### 技術的知見
1. **WAVエンコード**: 44バイトヘッダー + PCMデータ（Int16 little-endian）
2. **ダウンロード処理**: Blob URL → aタグclick → revokeURL のパターン
3. **UI確認**: 実装後はPlaywright MCPで必ずスクリーンショット確認

## 2025-12-14 音声キャッシュ機能・Xクリアボタン

### 概要
音声再生コントロールのUX改善。停止後も音声を保持して再生可能に、テキストクリア用のXボタンを追加。

### 作業内容

#### 1. 音声キャッシュ機構
- **目的**: 停止→再生で同じ音声を再生成するAPI呼び出しを削減
- **実装**:
  - `cachedAudioData`: Float32Array形式で音声保持
  - `cachedText`, `cachedVoice`, `cachedRate`: キャッシュ条件の記録
- **キャッシュ判定**: テキスト・音声・速度が全て一致したら再利用
- **再生時**: 「キャッシュから再生...」とステータス表示

#### 2. ボタン動作変更
| ボタン | 変更前 | 変更後 |
|--------|--------|--------|
| 再生 | 常にAPI呼び出し | キャッシュあれば再利用 |
| 停止 | 音声データクリア | 再生位置リセットのみ（キャッシュ保持） |

#### 3. Xクリアボタン
- **位置**: テキストエリア右上角
- **動作**: テキストクリア + 音声キャッシュクリア + フォーカス
- **表示制御**: テキストがある時のみ表示
- **UX**: 検索ボックスのX削除ボタンと同じパターン

#### 4. 設計議論
- **代替案検討**:
  - 5ボタン（再生/一時停止/停止/クリア/保存）→ 却下（煩雑）
  - テキスト変更で自動クリア → 却下（ペースト操作性の問題）
  - Xボタン in textarea → 採用（直感的、スペース効率良い）

### 技術的知見
1. **キャッシュ設計**: 音声生成条件（テキスト/音声/速度）を全て記録して完全一致で判定
2. **stopPlayback vs stop**: 内部用（キャッシュ保持）と外部用（停止ボタン）を分離
3. **clearCache vs clearAll**: キャッシュのみクリア vs 全状態リセット
4. **CSS position**: textarea内のボタンは`position: absolute`でテキストエリアを`position: relative`のラッパーで囲む

## 2025-12-14 テキスト処理改善・UI簡素化

### 概要
読み上げ品質向上のためのテキスト処理改善と、UIの大幅簡素化。

### 作業内容

#### 1. 数学記号の読み上げ
- **要望**: `高性能モデル＝リソースを大量消費` が `高性能モデルリソースを大量消費` と読まれる
- **対応**: 記号を読み上げ文字に変換
  - `＝` `=` → `、イコール、`（前後に休止）
  - `＋` `+` → `プラス`
  - `−` → `マイナス`（長音記号とはUnicodeで区別）
  - `×` `✕` → `かける`
  - `÷` → `わる`

#### 2. 改行での休止（SSML方式）
- **問題**: 句点なしの行末→次行が休止なく連続読み上げ
- **当初の試み**: 読点追加方式 → 効果なし（TTSが休止を入れない）
- **解決策**: SSMLの`<break>`タグを使用
  - 単一改行 → `<break time="300ms"/>`
  - 空行（段落区切り）→ `<break time="500ms"/>`
- **バックエンド対応**: `input: { ssml }` と `input: { text }` 両対応に

#### 3. UI簡素化
- **削除**: エンジン選択、音声リスト、速度スライダー、音量スライダー
- **追加**:
  - テキスト欄下に「Google Cloud TTS」表示
  - 音声: [女声] [男声] ボタン（女声デフォルト）
  - 速度: [1.0x] [1.2x] [1.5x] ボタン（1.2xデフォルト）
- **固定値**: 音量100%、エンジンはGoogle Cloud TTS

#### 4. 細かい修正
- 速度ボタン: `1x` → `1.0x` に表記変更
- ボタンサイズ: `min-width` 設定で統一
- イコール記号: 前後に読点追加で一拍の休止

### 技術的知見
1. **SSML**: Google Cloud TTSでは読点より`<break>`タグの方が確実に休止が入る
2. **XMLエスケープ**: SSML使用時は`&<>\"'`のエスケープ必須
3. **Unicode記号**: 長音記号`ー`(U+30FC)とマイナス`−`(U+2212)は別のコードポイントで区別可能
4. **ボタンサイズ統一**: `min-width`で最小幅を揃えるとテキスト長が違っても整列する
